# file: action.yml
name: 'Repo Slice'
author: 'AlienHeadwars'
description: 'Slices a repository and optionally pushes it to a new branch.'

inputs:
  manifest:
    description: 'The manifest content, provided as an inline string.'
    required: false
  manifestFile:
    description: 'Path to the manifest file containing filter rules.'
    required: false
  source:
    description: 'The source directory to read from.'
    required: false
    default: '.'
  output:
    description: 'The destination directory where the filtered copy will be created.'
    required: false
    default: 'sliced-repo'
  extension-map:
    description: 'A comma-separated list of `old:new` extension pairs to remap (e.g., `tsx:ts,mdx:md`).'
    required: false
  push-branch-name:
    description: 'The name of the branch to push the sliced contents to. If not set, no push will be performed.'
    required: false
  commit-message:
    description: 'The commit message to use when pushing the sliced branch.'
    required: false
    default: 'chore: Update repository slice'
  local-binary-path:
    description: 'Path to a local repo-slice binary. If set, the download step will be skipped. For testing purposes.'
    required: false

outputs:
  slice-path:
    description: "The path to the generated slice directory."
    value: ${{ steps.slice.outputs.path }}

runs:
  using: "composite"
  steps:
    - name: Download and prepare binary
      if: "inputs.local-binary-path == ''"
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        VERSION="v0.0.21" # Hardcoded version for stability
        echo "Downloading repo-slice binary for version $VERSION..."
        
        OS_ARCH=""
        case "${{ runner.os }}:${{ runner.arch }}" in
          Linux:X64)   OS_ARCH="linux_amd64" ;;
          Linux:ARM64) OS_ARCH="linux_arm64" ;;
          macOS:X64)   OS_ARCH="darwin_amd64" ;;
          macOS:ARM64) OS_ARCH="darwin_arm64" ;;
          Windows:X64) OS_ARCH="windows_amd64" ;;
          Windows:ARM64) OS_ARCH="windows_arm64" ;;
          *)
            echo "Error: Unsupported runner OS/architecture combination: ${{ runner.os }}/${{ runner.arch }}" >&2
            exit 1
            ;;
        esac

        ASSET_NAME="repo-slice_${VERSION#v}_${OS_ARCH}.tar.gz"
        
        echo "Downloading asset: $ASSET_NAME"
        gh release download "$VERSION" --pattern "$ASSET_NAME" --repo "AlienHeadWars/repo-slice"
        
        tar -xzf "$ASSET_NAME"
        chmod +x ./repo-slice

    - name: Run repo-slice
      id: slice
      shell: bash
      run: |
        # Step 1: Validate that exactly one manifest input is provided.
        if [ -n "${{ inputs.manifest }}" ] && [ -n "${{ inputs.manifestFile }}" ]; then
          echo "Error: Both 'manifest' and 'manifestFile' inputs cannot be used simultaneously." >&2
          exit 1
        fi
        if [ -z "${{ inputs.manifest }}" ] && [ -z "${{ inputs.manifestFile }}" ]; then
          echo "Error: Exactly one of 'manifest' or 'manifestFile' must be provided." >&2
          exit 1
        fi

        # Determine which binary to use
        BINARY_PATH="./repo-slice"
        if [ -n "${{ inputs.local-binary-path }}" ]; then
          BINARY_PATH="${{ inputs.local-binary-path }}"
        fi

        # Step 4: Handle the manifest input.
        MANIFEST_PATH=""
        if [ -n "${{ inputs.manifest }}" ]; then
          # If 'manifest' is set, write it to a temp file.
          MANIFEST_PATH=$(mktemp)
          echo "${{ inputs.manifest }}" > "$MANIFEST_PATH"
        else
          # Otherwise, use the path from 'manifestFile'.
          MANIFEST_PATH="${{ inputs.manifestFile }}"
        fi

        # Step 5: Construct and execute the repo-slice command.
        CMD="$BINARY_PATH --manifest \"$MANIFEST_PATH\" --source \"${{ inputs.source }}\" --output \"${{ inputs.output }}\""
        if [ -n "${{ inputs.extension-map }}" ]; then
          CMD="$CMD --extension-map \"${{ inputs.extension-map }}\""
        fi

        echo "Executing: $CMD"
        eval "$CMD"
        echo "path=${{ inputs.output }}" >> $GITHUB_OUTPUT

    - name: Push to branch
      if: "inputs.push-branch-name != ''"
      shell: bash
      run: |
        echo "--- Verifying Directory Contents ---"
        echo "Root directory listing:"
        ls -l
        
        echo "---"
        echo "Output directory listing:"
        ls -l "${{ inputs.output }}"
        echo "------------------------------------"

        # Change into the output directory, which is now its own git repository.
        cd "${{ inputs.output }}"
        
        # Use rsync to copy the parent's git configuration to handle permissions correctly.
        rsync -a ../.git/ ./.git/
        
        # Configure the git user.
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        
        # Add all files, commit, and force-push.
        git add .
        git commit -m "${{ inputs.commit-message }}"
        git push --force origin HEAD:${{ inputs.push-branch-name }}