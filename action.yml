# file: action.yml
name: 'Repo Slice'
author: 'AlienHeadwars'
description: 'Slices a repository by creating a filtered copy based on a manifest file, for use in CI/CD automation.'

inputs:
  manifest:
    description: 'The manifest content, provided as an inline string.'
    required: false
  manifestFile:
    description: 'Path to the manifest file containing filter rules.'
    required: false
  source:
    description: 'The source directory to read from.'
    required: false
    default: '.'
  output:
    description: 'The destination directory where the filtered copy will be created.'
    required: true
  extension-map:
    description: 'A comma-separated list of `old:new` extension pairs to remap (e.g., `tsx:ts,mdx:md`).'
    required: false

outputs:
  slice-path:
    description: "The path to the generated slice directory."
    value: ${{ steps.slice.outputs.path }}

runs:
  using: "composite"
  steps:
    - name: Run repo-slice
      id: slice
      shell: bash
      run: |
        # Step 1: Validate that exactly one manifest input is provided.
        if [ -n "${{ inputs.manifest }}" ] && [ -n "${{ inputs.manifestFile }}" ]; then
          echo "Error: Both 'manifest' and 'manifestFile' inputs cannot be used simultaneously." >&2
          exit 1
        fi
        if [ -z "${{ inputs.manifest }}" ] && [ -z "${{ inputs.manifestFile }}" ]; then
          echo "Error: Exactly one of 'manifest' or 'manifestFile' must be provided." >&2
          exit 1
        fi

        # Step 2: Download the repo-slice binary for the runner's OS/ARCH from the latest release.
        echo "Downloading repo-slice binary..."
        OS=$(echo ${{ runner.os }} | tr '[:upper:]' '[:lower:]')
        ARCH=$(echo ${{ runner.arch }} | tr '[:upper:]' '[:lower:]')
        ASSET_PATTERN="repo-slice_*_${OS}_${ARCH}.tar.gz"
        gh release download --latest --pattern "$ASSET_PATTERN" --repo "$GITHUB_REPOSITORY"
        tar -xzf "$ASSET_PATTERN"

        # Step 3: Make the downloaded binary executable.
        chmod +x ./repo-slice

        # Step 4: Handle the manifest input.
        MANIFEST_PATH=""
        if [ -n "${{ inputs.manifest }}" ]; then
          # If 'manifest' is set, write it to a temp file.
          MANIFEST_PATH=$(mktemp)
          echo "${{ inputs.manifest }}" > "$MANIFEST_PATH"
        else
          # Otherwise, use the path from 'manifestFile'.
          MANIFEST_PATH="${{ inputs.manifestFile }}"
        fi

        # Step 5: Construct and execute the repo-slice command.
        # Build the command with optional arguments
        CMD="./repo-slice --manifest \"$MANIFEST_PATH\" --source \"${{ inputs.source }}\" --output \"${{ inputs.output }}\""
        if [ -n "${{ inputs.extension-map }}" ]; then
          CMD="$CMD --extension-map \"${{ inputs.extension-map }}\""
        fi

        echo "Executing: $CMD"
        eval "$CMD"

        # Step 6: Set the output path.
        echo "path=${{ inputs.output }}" >> $GITHUB_OUTPUT