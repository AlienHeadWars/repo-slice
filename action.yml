# file: action.yml
name: 'Repo Slice'
author: 'AlienHeadwars'
description: 'Slices a repository and optionally pushes it to a new branch.'

branding:
  icon: 'scissors'
  color: 'blue'

inputs:
  manifest:
    description: 'The manifest content, provided as an inline string.'
    required: false
  manifest-file:
    description: 'Path to the manifest file containing filter rules.'
    required: false
  source:
    description: 'The source directory to read from.'
    required: false
    default: '.'
  output:
    description: 'The destination directory. If not set, a temporary directory will be created.'
    required: false
  extension-map:
    description: 'A multi-line string of `old:new` extension pairs to remap.'
    required: false
  push-branch-name:
    description: 'The name of the branch to push the sliced contents to. If not set, no push will be performed.'
    required: false
  commit-message:
    description: 'The commit message to use when pushing the sliced branch.'
    required: false
    default: 'chore: Update repository slice'
  local-binary-path:
    description: 'Path to a local repo-slice binary. If set, the download step will be skipped. For testing purposes.'
    required: false
  max-files:
    description: 'The maximum number of files allowed in the slice. The action will fail if this is exceeded.'
    required: false
    default: '5000'
  max-size:
    description: 'The maximum total size of the slice (e.g., `100M`). The action will fail if this is exceeded.'
    required: false
    default: '100M'

outputs:
  slice-path:
    description: "The path to the generated slice directory."
    value: ${{ steps.slice.outputs.path }}

runs:
  using: "composite"
  steps:
    - name: Prepare binary path
      id: binary_path
      shell: bash
      run: |
        if [ -n "${{ inputs.local-binary-path }}" ]; then
          echo "path=${{ inputs.local-binary-path }}" >> $GITHUB_OUTPUT
        else
          TEMP_DIR=$(mktemp -d)
          echo "path=$TEMP_DIR/repo-slice" >> $GITHUB_OUTPUT
          echo "dir=$TEMP_DIR" >> $GITHUB_OUTPUT
        fi

    - name: Download and prepare binary
      if: "inputs.local-binary-path == ''"
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        TEMP_DIR: ${{ steps.binary_path.outputs.dir }}
      run: |
        VERSION="v1.2.2" # Hardcoded version for stability
        echo "Downloading repo-slice binary for version $VERSION..."
        
        OS_ARCH=""
        case "${{ runner.os }}:${{ runner.arch }}" in
          Linux:X64)   OS_ARCH="linux_amd64" ;;
          Linux:ARM64) OS_ARCH="linux_arm64" ;;
          macOS:X64)   OS_ARCH="darwin_amd64" ;;
          macOS:ARM64) OS_ARCH="darwin_arm64" ;;
          Windows:X64) OS_ARCH="windows_amd64" ;;
          Windows:ARM64) OS_ARCH="windows_arm64" ;;
          *)
            echo "Error: Unsupported runner OS/architecture combination: ${{ runner.os }}/${{ runner.arch }}" >&2
            exit 1
            ;;
        esac

        ASSET_NAME="repo-slice_${VERSION#v}_${OS_ARCH}.tar.gz"
        
        # The binary is downloaded to a temporary directory to prevent it from
        # being included in the repository slice.
        gh release download "$VERSION" --pattern "$ASSET_NAME" --repo "AlienHeadWars/repo-slice" --clobber -D "$TEMP_DIR"
        
        tar -xzf "$TEMP_DIR/$ASSET_NAME" -C "$TEMP_DIR"
        chmod +x "$TEMP_DIR/repo-slice"

    - name: Run repo-slice
      id: slice
      shell: bash
      run: |
        # To provide a clear user experience, the action must fail if the manifest
        # source is ambiguous (both provided) or missing (neither provided).
        if [ -n "${{ inputs.manifest }}" ] && [ -n "${{ inputs.manifest-file }}" ]; then
          echo "Error: Both 'manifest' and 'manifest-file' inputs cannot be used simultaneously." >&2
          exit 1
        fi
        if [ -z "${{ inputs.manifest }}" ] && [ -z "${{ inputs.manifest-file }}" ]; then
          echo "Error: Exactly one of 'manifest' or 'manifest-file' must be provided." >&2
          exit 1
        fi

        # To ensure multiple runs of the action in the same job are isolated,
        # a temporary directory is used for the output if one is not specified.
        OUTPUT_PATH="${{ inputs.output }}"
        if [ -z "$OUTPUT_PATH" ]; then
          OUTPUT_PATH=$(mktemp -d)
        fi

        # The action must support both local testing (via local-binary-path)
        # and production runs (downloading from a release).
        BINARY_PATH="${{ steps.binary_path.outputs.path }}"

        # To support both inline and file-based manifests, we normalize the
        # input into a single MANIFEST_PATH variable.
        MANIFEST_PATH=""
        if [ -n "${{ inputs.manifest }}" ]; then
          MANIFEST_PATH=$(mktemp)
          echo "${{ inputs.manifest }}" > "$MANIFEST_PATH"
        else
          MANIFEST_PATH="${{ inputs.manifest-file }}"
        fi

        # To provide a user-friendly YAML interface, the multi-line extension-map
        # must be converted to the comma-separated format the CLI expects.
        EXTENSION_MAP_ARG=""
        if [ -n "${{ inputs.extension-map }}" ]; then
          COMMA_SEPARATED_MAP=$(echo "${{ inputs.extension-map }}" | awk 'NF' | paste -sd, -)
          EXTENSION_MAP_ARG="--extension-map \"$COMMA_SEPARATED_MAP\""
        fi

        CMD="$BINARY_PATH --manifest \"$MANIFEST_PATH\" --source \"${{ inputs.source }}\" --output \"$OUTPUT_PATH\" $EXTENSION_MAP_ARG"
        
        echo "Executing: $CMD"
        eval "$CMD"
        echo "path=$OUTPUT_PATH" >> $GITHUB_OUTPUT

    - name: Validate slice contents
      shell: bash
      run: |
        FILE_COUNT=$(find "${{ steps.slice.outputs.path }}" -type f | wc -l)
        MAX_FILES=${{ inputs.max-files }}

        echo "Slice contains $FILE_COUNT files."
        if [ "$FILE_COUNT" -gt "$MAX_FILES" ]; then
          echo "Error: File count ($FILE_COUNT) exceeds the maximum allowed ($MAX_FILES)." >&2
          exit 1
        fi

    - name: Validate slice size
      shell: bash
      run: |
        SIZE_IN_BYTES=$(du -sb "${{ steps.slice.outputs.path }}" | cut -f1)
        MAX_SIZE_INPUT="${{ inputs.max-size }}"
        
        # awk is used to parse common size suffixes (K, M, G, T) into a
        # comparable byte value.
        MAX_SIZE_BYTES=$(echo "$MAX_SIZE_INPUT" | awk \
          'BEGIN{IGNORECASE=1; K=1024; M=K*K; G=M*K; T=G*K}
           /K/{val=$1*K} /M/{val=$1*M} /G/{val=$1*G} /T/{val=$1*T}
           END{print val}')
        
        echo "Slice size is $SIZE_IN_BYTES bytes."
        if [ "$SIZE_IN_BYTES" -gt "$MAX_SIZE_BYTES" ]; then
          echo "Error: Slice size ($SIZE_IN_BYTES bytes) exceeds the maximum allowed ($MAX_SIZE_INPUT)." >&2
          exit 1
        fi

    - name: Prepare repository for push
      if: "inputs.push-branch-name != ''"
      shell: bash
      run: |
        # To push the sliced directory as its own repository, it needs a .git
        # directory with the correct remote origin.
        rsync -a ./.git/ "${{ steps.slice.outputs.path }}/.git/"

    - name: Push to branch
      if: "inputs.push-branch-name != ''"
      uses: stefanzweifel/git-auto-commit-action@778341af668090896ca464160c2def5d1d1a3eb0 # Pinned to v6.0.1
      with:
        repository: ${{ steps.slice.outputs.path }}
        commit_message: ${{ inputs.commit-message }}
        branch: ${{ inputs.push-branch-name }}
        push_options: '--force'
